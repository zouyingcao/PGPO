<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Generated by indoc on 29 May 2018 -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link href="indoc_RB.css" rel="stylesheet" type="text/css" />
<title>1.4. Information Only</title>
<script type="text/javascript">
    function showExtra(id, imid) {
        if (document.getElementById(id).style.display == 'block') {
            document.getElementById(id).style.display = 'none';
            document.getElementById(imid).src = 'Documentation/Images/extra.png';
        } else {
            document.getElementById(id).style.display = 'block';
            document.getElementById(imid).src = 'Documentation/Images/extraclose.png';
        }
    }
    function onLoaded() {
        if (window.location.hash) {
            var hash = window.location.hash.substring(2);
            if (hash.search("_") >= 0) {
                var res = hash.split("_");
                showExample("example"+res[1]);
            } else {
                showExample("example"+hash);
            }
        }
    }
    window.onload=onLoaded;
    function showExample(id) {
        if (document.getElementById(id).style.display == 'block') {
            document.getElementById(id).style.display = 'none';
        } else {
            document.getElementById(id).style.display = 'block';
        }
    }
    function openExtra(id, imid) {
        document.getElementById(id).style.display = 'block';
        document.getElementById(imid).src = 'Documentation/Images/extraclose.png';
    }
    function closeExtra(id, imid) {
        document.getElementById(id).style.display = 'none';
        document.getElementById(imid).src = 'Documentation/Images/extra.png';
    }
</script>
</head>
<body class="paper papertint"><script language="JavaScript">
function pasteCode(code) {
    var myProject = window.Project;

    myProject.selectView('source');
    myProject.pasteCode(code);
}
</script>
<script language="JavaScript">
function createNewProject(code, title) {
    var myProject = window.Project;

    myProject.createNewProject(title, code);
}
</script>
<p class="sectionheading">§1.4. Information Only</p>
<p>One last preliminary: a handful of the examples do not show how to do anything at all, but are really sidebars of information. Those examples are gathered below, since they contribute nothing by way of recipes.</p>
<hr />
<div class="roadsigns">
<table><tr><td class="roadsigndirection"><a href="RB_1_1.html" class="standardlink"><img alt="arrow-up.png" src="Documentation/Images/arrow-up.png" /></a></td><td><a href="RB_1_1.html" class="standardlink">Start of Chapter 1: How to Use The Recipe Book</a></td></tr>
<tr><td class="roadsigndirection"><a href="RB_1_3.html" class="standardlink"><img alt="arrow-left.png" src="Documentation/Images/arrow-left.png" /></a></td><td><a href="RB_1_3.html" class="standardlink">Back to §1.3. Disenchantment Bay</a></td></tr>
<tr><td class="roadsigndirection"><a href="RB_2_1.html" class="standardlink"><img alt="arrow-right.png" src="Documentation/Images/arrow-right.png" /></a></td><td><a href="RB_2_1.html" class="standardlink">Onward to Chapter 2: Adaptive Prose: §2.1. Varying What Is Written</a></td></tr>
</table><hr />
</div>
<div class="bookexamples">
<p class="chapterheading"></p><a id="e175"></a><table class="egcue"><tr><td class="egcellforoval"><div class="egovalfornumber overstruckimage">
<!-- EXAMPLE START -->
<a href="RB_1_4.html#e175" class="eglink"><b>414</b></a></div>
<div class="egpanel" id="example175">
<p>There is not really any unanimity about what regular expression language is. The unix tools sed and grep extend on Kleene's original grammar. Henry Spencer's regex library extended on this again, and was a foundation for Perl, but Perl once again went further. Philip Hazel's PCRE, despite the name Perl Compatible Regular Expressions, makes further extensions still, and so on.</p>
<p>Inform's regular expressions are modelled on those of Perl, as the best de facto standard we have, but a few omissions have been inevitable. Inform's regex matcher must occupy source code less than one hundredth the size of PCRE, and it has very little memory. Inform aims to behave exactly like Perl except as follows:</p>
<!-- START CODE "c29209" -->
<a id="c29209"></a><blockquote class="code"><p class="quoted">
(i) Inform allows angle brackets as synonymous with square brackets, for reasons explained above. This means literal angle brackets have to be escaped as &quot;\&lt;&quot; and &quot;\&gt;&quot; in Inform regular expressions, which is unnecessary in Perl.
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29210" -->
<a id="c29210"></a><blockquote class="code"><p class="quoted">
(ii) Inform only has single-line mode, not multiline mode: this removes need for the mode-switches &quot;(?m)&quot; and &quot;(?s)&quot; and the positional markers &quot;\A&quot; and &quot;\Z&quot;. Multiline mode is idiosyncratic to Perl and is a messy compromise to do with holding long files of text as single strings, yet treating them as lists of lines at the same time: this would not be sensible for Inform. Similarly, because there is no ambiguity about how line breaks are represented in Inform strings (by a single &quot;\n&quot;), initial newline convention markers such as &quot;(*ANYCRLF)&quot; are unsupported.
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29211" -->
<a id="c29211"></a><blockquote class="code"><p class="quoted">
(iii) The codes &quot;\a&quot;, &quot;\r&quot;, &quot;\f&quot;, &quot;\e&quot;, &quot;\0&quot; for alarm, carriage return, form feed, escape and the zero character are unsupported: none of these can occur in an Inform string.
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29212" -->
<a id="c29212"></a><blockquote class="code"><p class="quoted">
(iv) Inform does not allow characters to be referred to by character code (whereas Perl allows &quot;\036&quot; for an octal character code, &quot;\x7e&quot; for a hexadecimal one, &quot;\cD&quot; for a control character). This is because we do not want the user to know whether text is internally stored as ZSCII or Unicode.
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29213" -->
<a id="c29213"></a><blockquote class="code"><p class="quoted">
(v) Inform's character class &quot;\p&quot; (and its negation &quot;\P&quot;) have no equivalent in Perl, and Inform's understanding of &quot;\w&quot; is different. Perl defines this as an upper or lower case English letter, underscore or digit, which is good for programming-language identifiers, but bad for natural language - for instance, &quot;é&quot; is not matched by &quot;\w&quot; in Perl, but unquestionably it appears in words. Inform therefore defines &quot;\w&quot; as the negation of &quot;\s&quot; union &quot;\p&quot;.
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29214" -->
<a id="c29214"></a><blockquote class="code"><p class="quoted">
(vi) Inform supports only single-digit grouping numbers &quot;\1&quot; to &quot;\9&quot;, whereas Perl allows &quot;\10&quot;, &quot;\11&quot;, ...
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29215" -->
<a id="c29215"></a><blockquote class="code"><p class="quoted">
(vii) POSIX named character ranges are not supported. These are only abbreviations in any case, and are not very useful. (Note that the POSIX range &quot;[:punct:]&quot;, which is supposedly for punctuation, includes many things we do not want to think of that way - percentage signs, for instance - and so &quot;\p&quot; has a more natural-language-based definition.)
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29216" -->
<a id="c29216"></a><blockquote class="code"><p class="quoted">
(viii) Character classes can be used inside ranges, so that &quot;&lt;\da-f&gt;&quot; is legal, but not as ends of contiguous runs, so that &quot;&lt;\d-X&gt;&quot; is not legal. (As reckless as this is, it is legal in Perl.)
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29217" -->
<a id="c29217"></a><blockquote class="code"><p class="quoted">
(ix) For obvious reasons, escapes to Perl code using the notation &quot;(?{...})&quot; are unsupported, and so is the Perl iteration operator &quot;\G&quot;.
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29218" -->
<a id="c29218"></a><blockquote class="code"><p class="quoted">
(x) Perl's extended mode &quot;(?x)&quot;, a lexical arrangement which allows expressions to be expanded out as little computer programs with comments, is unsupported. It would look awful syntax-coloured in the Inform interface and is not a style of coding to be encouraged.
</p></blockquote>
<!-- END CODE -->
<p>Inform further does not support the Python extension of named subexpression groups, nor the Java extension of the possessive quantifier &quot;++&quot;. There was only so much functionality we could squeeze in.</p>
<p>As verification of Inform's matching algorithm, we took the Perl 5 source code's notorious &quot;re-test.txt&quot; set of 961 test cases, removed the 316 using features unsupported by Inform (220 tested multiline mode, for instance), and ran the remaining 645 cases through Inform. It agrees with Perl on 643 of these: the two outstanding are -</p>
<!-- START CODE "c29219" -->
<a id="c29219"></a><blockquote class="code"><p class="quoted">
(i) Perl is able to match &quot;^(a\1?){4}$&quot; against &quot;aaaaaa&quot; but Inform is not - Inform's backtracking is not as good when it comes to repetitions of groupings which are recursively defined. (Note that the optional &quot;\1&quot; match refers to the value of the bracketed expression which contains it, so that the interpretation is different on each repetition. Here to match we have to interpret &quot;?&quot; as 0, 0, 1, 0 repeats respectively as we work through the &quot;{4}&quot;.)
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29220" -->
<a id="c29220"></a><blockquote class="code"><p class="quoted">
(ii) Perl matches &quot;((&lt;a-c&gt;)b*?\2)*&quot; against &quot;ababbbcbc&quot; finding the match &quot;ababb&quot;, whereas Inform finds the match &quot;ababbbcbc&quot;. This is really a difference of opinion about whether the outer asterisk, which is greedy, should be allowed three matches rather than two if to do so requires the inner asterisk, which is not greedy, to eat more than it needs on one of those three matches.
</p></blockquote>
<!-- END CODE -->
<p>Case (i) is a sacrifice to enable Inform's back-tracking to use less memory. Case (ii) simply seems unimportant.</p>
</div>
<!-- EXAMPLE END -->
<!-- EXAMPLE START -->
</td><td class="egnamecell"><p class="egcuetext"><a href="RB_1_4.html#e175" class="eglink"><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><b><span class="egbanner"><b>Example</b></span><span class="egname">About Inform's regular expression support</span></b></a><br />Some footnotes on Inform's regular expressions, and how they compare to those of other programming languages.</p></td><td class="egcrossref"><!-- START IGNORE -->
<div class="egpanel" id="example175">
<p>There is not really any unanimity about what regular expression language is. The unix tools sed and grep extend on Kleene's original grammar. Henry Spencer's regex library extended on this again, and was a foundation for Perl, but Perl once again went further. Philip Hazel's PCRE, despite the name Perl Compatible Regular Expressions, makes further extensions still, and so on.</p>
<p>Inform's regular expressions are modelled on those of Perl, as the best de facto standard we have, but a few omissions have been inevitable. Inform's regex matcher must occupy source code less than one hundredth the size of PCRE, and it has very little memory. Inform aims to behave exactly like Perl except as follows:</p>
<!-- START CODE "c29221" -->
<a id="c29221"></a><blockquote class="code"><p class="quoted">
(i) Inform allows angle brackets as synonymous with square brackets, for reasons explained above. This means literal angle brackets have to be escaped as &quot;\&lt;&quot; and &quot;\&gt;&quot; in Inform regular expressions, which is unnecessary in Perl.
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29222" -->
<a id="c29222"></a><blockquote class="code"><p class="quoted">
(ii) Inform only has single-line mode, not multiline mode: this removes need for the mode-switches &quot;(?m)&quot; and &quot;(?s)&quot; and the positional markers &quot;\A&quot; and &quot;\Z&quot;. Multiline mode is idiosyncratic to Perl and is a messy compromise to do with holding long files of text as single strings, yet treating them as lists of lines at the same time: this would not be sensible for Inform. Similarly, because there is no ambiguity about how line breaks are represented in Inform strings (by a single &quot;\n&quot;), initial newline convention markers such as &quot;(*ANYCRLF)&quot; are unsupported.
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29223" -->
<a id="c29223"></a><blockquote class="code"><p class="quoted">
(iii) The codes &quot;\a&quot;, &quot;\r&quot;, &quot;\f&quot;, &quot;\e&quot;, &quot;\0&quot; for alarm, carriage return, form feed, escape and the zero character are unsupported: none of these can occur in an Inform string.
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29224" -->
<a id="c29224"></a><blockquote class="code"><p class="quoted">
(iv) Inform does not allow characters to be referred to by character code (whereas Perl allows &quot;\036&quot; for an octal character code, &quot;\x7e&quot; for a hexadecimal one, &quot;\cD&quot; for a control character). This is because we do not want the user to know whether text is internally stored as ZSCII or Unicode.
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29225" -->
<a id="c29225"></a><blockquote class="code"><p class="quoted">
(v) Inform's character class &quot;\p&quot; (and its negation &quot;\P&quot;) have no equivalent in Perl, and Inform's understanding of &quot;\w&quot; is different. Perl defines this as an upper or lower case English letter, underscore or digit, which is good for programming-language identifiers, but bad for natural language - for instance, &quot;é&quot; is not matched by &quot;\w&quot; in Perl, but unquestionably it appears in words. Inform therefore defines &quot;\w&quot; as the negation of &quot;\s&quot; union &quot;\p&quot;.
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29226" -->
<a id="c29226"></a><blockquote class="code"><p class="quoted">
(vi) Inform supports only single-digit grouping numbers &quot;\1&quot; to &quot;\9&quot;, whereas Perl allows &quot;\10&quot;, &quot;\11&quot;, ...
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29227" -->
<a id="c29227"></a><blockquote class="code"><p class="quoted">
(vii) POSIX named character ranges are not supported. These are only abbreviations in any case, and are not very useful. (Note that the POSIX range &quot;[:punct:]&quot;, which is supposedly for punctuation, includes many things we do not want to think of that way - percentage signs, for instance - and so &quot;\p&quot; has a more natural-language-based definition.)
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29228" -->
<a id="c29228"></a><blockquote class="code"><p class="quoted">
(viii) Character classes can be used inside ranges, so that &quot;&lt;\da-f&gt;&quot; is legal, but not as ends of contiguous runs, so that &quot;&lt;\d-X&gt;&quot; is not legal. (As reckless as this is, it is legal in Perl.)
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29229" -->
<a id="c29229"></a><blockquote class="code"><p class="quoted">
(ix) For obvious reasons, escapes to Perl code using the notation &quot;(?{...})&quot; are unsupported, and so is the Perl iteration operator &quot;\G&quot;.
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29230" -->
<a id="c29230"></a><blockquote class="code"><p class="quoted">
(x) Perl's extended mode &quot;(?x)&quot;, a lexical arrangement which allows expressions to be expanded out as little computer programs with comments, is unsupported. It would look awful syntax-coloured in the Inform interface and is not a style of coding to be encouraged.
</p></blockquote>
<!-- END CODE -->
<p>Inform further does not support the Python extension of named subexpression groups, nor the Java extension of the possessive quantifier &quot;++&quot;. There was only so much functionality we could squeeze in.</p>
<p>As verification of Inform's matching algorithm, we took the Perl 5 source code's notorious &quot;re-test.txt&quot; set of 961 test cases, removed the 316 using features unsupported by Inform (220 tested multiline mode, for instance), and ran the remaining 645 cases through Inform. It agrees with Perl on 643 of these: the two outstanding are -</p>
<!-- START CODE "c29231" -->
<a id="c29231"></a><blockquote class="code"><p class="quoted">
(i) Perl is able to match &quot;^(a\1?){4}$&quot; against &quot;aaaaaa&quot; but Inform is not - Inform's backtracking is not as good when it comes to repetitions of groupings which are recursively defined. (Note that the optional &quot;\1&quot; match refers to the value of the bracketed expression which contains it, so that the interpretation is different on each repetition. Here to match we have to interpret &quot;?&quot; as 0, 0, 1, 0 repeats respectively as we work through the &quot;{4}&quot;.)
</p></blockquote>
<!-- END CODE -->
<!-- START CODE "c29232" -->
<a id="c29232"></a><blockquote class="code"><p class="quoted">
(ii) Perl matches &quot;((&lt;a-c&gt;)b*?\2)*&quot; against &quot;ababbbcbc&quot; finding the match &quot;ababb&quot;, whereas Inform finds the match &quot;ababbbcbc&quot;. This is really a difference of opinion about whether the outer asterisk, which is greedy, should be allowed three matches rather than two if to do so requires the inner asterisk, which is not greedy, to eat more than it needs on one of those three matches.
</p></blockquote>
<!-- END CODE -->
<p>Case (i) is a sacrifice to enable Inform's back-tracking to use less memory. Case (ii) simply seems unimportant.</p>
</div>
<!-- EXAMPLE END -->
<div class="egovalforxref overstruckimage">
<a  href="ex175.html#e175"><i>WI</i></a></div>
<!-- END IGNORE -->
</td></tr></table>
<a id="e304"></a><table class="egcue"><tr><td class="egcellforoval"><div class="egovalfornumber overstruckimage">
<a href="Rex304.html#e304" class="eglink"><b>223</b></a></div>
</td><td class="egnamecell"><p class="egcuetext"><a href="Rex304.html#e304" class="eglink"><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><b><span class="egbanner">Example</span><span class="egname">Formal syntax of sentences</span></b></a><br />A more formal description of the sentence grammar used by Inform for both assertions and conditions.</p></td><td class="egcrossref"><!-- START IGNORE -->
<div class="egovalforxref overstruckimage">
<a  href="ex304.html#e304"><i>WI</i></a></div>
<!-- END IGNORE -->
</td></tr></table>
<a id="e37"></a><table class="egcue"><tr><td class="egcellforoval"><div class="egovalfornumber overstruckimage">
<a href="Rex37.html#e37" class="eglink"><b>243</b></a></div>
</td><td class="egnamecell"><p class="egcuetext"><a href="Rex37.html#e37" class="eglink"><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><b><span class="egbanner">Example</span><span class="egname">Mathematical view of relations</span></b></a><br />Some notes on relations from a mathematical point of view, provided only to clarify some technicalities for those who are interested.</p></td><td class="egcrossref"><!-- START IGNORE -->
<div class="egovalforxref overstruckimage">
<a  href="ex37.html#e37"><i>WI</i></a></div>
<!-- END IGNORE -->
</td></tr></table>
<a id="e198"></a><table class="egcue"><tr><td class="egcellforoval"><div class="egovalfornumber overstruckimage">
<a href="Rex198.html#e198" class="eglink"><b>244</b></a></div>
</td><td class="egnamecell"><p class="egcuetext"><a href="Rex198.html#e198" class="eglink"><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><b><span class="egbanner">Example</span><span class="egname">Graph-theory view of relations</span></b></a><br />Some notes on relations from the point of view of graph theory.</p></td><td class="egcrossref"><!-- START IGNORE -->
<div class="egovalforxref overstruckimage">
<a  href="ex198.html#e198"><i>WI</i></a></div>
<!-- END IGNORE -->
</td></tr></table>
<a id="e237"></a><table class="egcue"><tr><td class="egcellforoval"><div class="egovalfornumber overstruckimage">
<a href="Rex237.html#e237" class="eglink"><b>399</b></a></div>
</td><td class="egnamecell"><p class="egcuetext"><a href="Rex237.html#e237" class="eglink"><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><b><span class="egbanner">Example</span><span class="egname">Backus-Naur form for rules</span></b></a><br />The full grammar Inform uses to parse rule definitions, in a standard computer-science notation.</p></td><td class="egcrossref"><!-- START IGNORE -->
<div class="egovalforxref overstruckimage">
<a  href="ex237.html#e237"><i>WI</i></a></div>
<!-- END IGNORE -->
</td></tr></table>
<hr />
</div>
<!-- START IGNORE -->
<!-- END IGNORE -->
</body>
</html>
