<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Generated by indoc on 29 May 2018 -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link href="indoc_WI.css" rel="stylesheet" type="text/css" />
<title>13.16. What are relations for?</title>
<script type="text/javascript">
    function showExtra(id, imid) {
        if (document.getElementById(id).style.display == 'block') {
            document.getElementById(id).style.display = 'none';
            document.getElementById(imid).src = 'Documentation/Images/extra.png';
        } else {
            document.getElementById(id).style.display = 'block';
            document.getElementById(imid).src = 'Documentation/Images/extraclose.png';
        }
    }
    function onLoaded() {
        if (window.location.hash) {
            var hash = window.location.hash.substring(2);
            if (hash.search("_") >= 0) {
                var res = hash.split("_");
                showExample("example"+res[1]);
            } else {
                showExample("example"+hash);
            }
        }
    }
    window.onload=onLoaded;
    function showExample(id) {
        if (document.getElementById(id).style.display == 'block') {
            document.getElementById(id).style.display = 'none';
        } else {
            document.getElementById(id).style.display = 'block';
        }
    }
    function openExtra(id, imid) {
        document.getElementById(id).style.display = 'block';
        document.getElementById(imid).src = 'Documentation/Images/extraclose.png';
    }
    function closeExtra(id, imid) {
        document.getElementById(id).style.display = 'none';
        document.getElementById(imid).src = 'Documentation/Images/extra.png';
    }
</script>
</head>
<body class="paper papertint"><script language="JavaScript">
function pasteCode(code) {
    var myProject = window.Project;

    myProject.selectView('source');
    myProject.pasteCode(code);
}
</script>
<script language="JavaScript">
function createNewProject(code, title) {
    var myProject = window.Project;

    myProject.createNewProject(title, code);
}
</script>
<p class="sectionheading">ยง13.16. What are relations for?</p>
<p>It is easy to say what verbs are for: they are to express relations. But what are relations for?</p>
<p>Inform 7's focus on relations between objects is unusual as an approach to interactive fiction; the concept does not exist in most design systems, or rather, it does but is submerged. Traditional design systems do, after all, have the spatial relations of being inside, on top of, and so on. It could well be said that these are the only relationships that inanimate objects ever have. A stone can be on top of a table, and if so then that expresses their entire association.</p>
<p>This is because the stone, and the table, have no opinions, emotions, knowledge or memory. If the stone is taken away and then put back, nothing has changed. People, on the other hand, tend to remember having met each other before; they like being in some places, but not others; their behaviour depends on who, or what, is nearby. Being conscious, they have internal states, unlike the stone. Relations are a simple but powerful way to express and talk about such connections, and although they have numerous uses in physical contexts too, they are at their most powerful when helping to make the characters of interactive fiction come alive.</p>
<hr />
<div class="roadsigns">
<table><tr><td class="roadsigndirection"><a href="WI_13_1.html" class="standardlink"><img alt="arrow-up.png" src="Documentation/Images/arrow-up.png" /></a></td><td><a href="WI_13_1.html" class="standardlink">Start of Chapter 13: Relations</a></td></tr>
<tr><td class="roadsigndirection"><a href="WI_13_15.html" class="standardlink"><img alt="arrow-left.png" src="Documentation/Images/arrow-left.png" /></a></td><td><a href="WI_13_15.html" class="standardlink">Back to ยง13.15. Temporary relations</a></td></tr>
<tr><td class="roadsigndirection"><a href="WI_14_1.html" class="standardlink"><img alt="arrow-right.png" src="Documentation/Images/arrow-right.png" /></a></td><td><a href="WI_14_1.html" class="standardlink">Onward to Chapter 14: Adaptive Text and Responses: ยง14.1. Tense and narrative viewpoint</a></td></tr>
</table><hr />
</div>
<div class="bookexamples">
<p class="chapterheading"></p><a id="e248"></a><table class="egcue"><tr><td class="egcellforoval"><div class="egovalfornumber overstruckimage">
<a href="ex248.html#e248" class="eglink"><b>241</b></a></div>
</td><td class="egnamecell"><p class="egcuetext"><a href="ex248.html#e248" class="eglink"><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><b><span class="egbanner">Example</span><span class="egname">Murder on the Orient Express</span></b></a><br />A number of sleuths (the player among them) find themselves aboard the Orient Express, where a murder has taken place, and one of them is apparently the culprit. Naturally they do not agree on whom, but there is physical evidence which may change their minds...</p></td><td class="egcrossref"><!-- START IGNORE -->
<div class="egovalforxref overstruckimage">
<a  href="Rex248.html#e248"><i>RB</i></a></div>
<!-- END IGNORE -->
</td></tr></table>
<a id="e363"></a><table class="egcue"><tr><td class="egcellforoval"><div class="egovalfornumber overstruckimage">
<a href="ex363.html#e363" class="eglink"><b>242</b></a></div>
</td><td class="egnamecell"><p class="egcuetext"><a href="ex363.html#e363" class="eglink"><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><b><span class="egbanner">Example</span><span class="egname">What Not To Wear</span></b></a><br />A general-purpose clothing system that handles a variety of different clothing items layered in different combinations over different areas of the body.</p></td><td class="egcrossref"><!-- START IGNORE -->
<div class="egovalforxref overstruckimage">
<a  href="Rex363.html#e363"><i>RB</i></a></div>
<!-- END IGNORE -->
</td></tr></table>
<a id="e37"></a><table class="egcue"><tr><td class="egcellforoval"><div class="egovalfornumber overstruckimage">
<a href="ex37.html#e37" class="eglink"><b>243</b></a></div>
</td><td class="egnamecell"><p class="egcuetext"><a href="ex37.html#e37" class="eglink"><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><b><span class="egbanner">Example</span><span class="egname">Mathematical view of relations</span></b></a><br />Some notes on relations from a mathematical point of view, provided only to clarify some technicalities for those who are interested.</p></td><td class="egcrossref"><!-- START IGNORE -->
<div class="egovalforxref overstruckimage">
<a  href="Rex37.html#e37"><i>RB</i></a></div>
<!-- END IGNORE -->
</td></tr></table>
<a id="e198"></a><table class="egcue"><tr><td class="egcellforoval"><div class="egovalfornumber overstruckimage">
<!-- EXAMPLE START -->
<a href="WI_13_16.html#e198" class="eglink"><b>244</b></a></div>
<div class="egpanel" id="example198">
<p>One way to look at a relation is to regard it as a directed graph: that is, a collection of things (&quot;vertices&quot;) with arrows drawn between them (&quot;edges&quot;). We write our items A, B, C, ... on a piece of paper: then, if A relates to B, we draw an arrow pointing from A to B, and so on. If we made this drawing for the adjacency relation, we would more or less have reconstructed the map (or at least a simplified one which does not care about precise directions, like the famous diagram of the London Underground). But the drawing can be made for any relation. If we define:</p>
<!-- START CODE "c11239" -->
<a id="c11239"></a><blockquote class="code"><p class="quoted">
Suspecting relates various people to one person.
</p></blockquote>
<!-- END CODE -->
<p>then, in the corresponding graph, each &quot;vertex&quot; will have at most one arrow leading away from it - though there could be many (or none) leading towards. Conversely, a one-to-various relation produces a graph where each vertex has at most one arrow coming in. A one-to-one relation means that the picture consists of some vertices on their own, with no arrows, a few perhaps with looped arrows leading from and to themselves, and then a collection of pairs joined by arrows. On the other hand, a various-to-various relation is just a free-for-all, with no restrictions on the arrows. The relations:</p>
<!-- START CODE "c11240" -->
<a id="c11240"></a><blockquote class="code"><p class="quoted">
Meeting relates people to each other.
<br />Marriage relates one person to another.
</p></blockquote>
<!-- END CODE -->
<p>always have the property of working both ways round, and these are easiest to visualise by forgetting the direction of the arrows, so that they just become lines joining the vertices.</p>
<p>Inform uses a different algorithm for finding routes (&quot;the next step via R from A to B&quot;) in each of these cases, and internally it stores relations in different formats in the different cases, because it makes a big difference to the efficiency of Inform to minimise the storage required for a relation and the time taken to explore it.</p>
<p>All the cases are benign except for &quot;various to various&quot; - the most useful - and for its closely related symmetrical version, &quot;relates... to each other&quot;. Inform cannot afford to assume that the relation will be &quot;sparse&quot; (that is: that no vertex will have more than a certain number of arrows, or that the total number of arrows will be small), because it has no idea how the arrows will come and go during play. It therefore uses 1 bit of storage for each pair of objects. This sounds harmless, but if there are 200 rooms, there are 40,000 pairs of rooms, which means a 5000-byte allocation of storage (plus a handful of bytes as overhead). Gratuitous various-to-various relations are therefore not a good idea.</p>
<p>There is a standard algorithm for calculating shortest paths through a directed graph, but Inform does not always use it, because there is not always memory to store the required matrix of partial results. Inform's slow method, likely to be used on the Z-machine, requires a storage overhead which is equal to the number of vertices, not the square of that number, but the worst-case running time can be bad: if there are N vertices, and the diameter of graph (the longest distance between vertices) is D, then the running time is proportional to D times N. The worst case in finding routes from A to B is when almost every vertex can reach B, some across long trails, but A cannot. In the case of finding routes across the game's map, this must be multiplied further by the number of possible directions - usually 16.</p>
<p>This does not sound too awful, but if one is trying to find (say) &quot;the most distant room from A&quot;, that means a further loop and now the running time will be D times N squared. Extension writers will need to be careful of this kind of thing: it is easy to write highly cool prototypes which work terribly slowly on larger, more realistic maps.</p>
</div>
<!-- EXAMPLE END -->
<!-- EXAMPLE START -->
</td><td class="egnamecell"><p class="egcuetext"><a href="WI_13_16.html#e198" class="eglink"><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><img class="asterisk" alt="*" src="Documentation/Images/asterisk.png" /><b><span class="egbanner"><b>Example</b></span><span class="egname">Graph-theory view of relations</span></b></a><br />Some notes on relations from the point of view of graph theory.</p></td><td class="egcrossref"><!-- START IGNORE -->
<div class="egpanel" id="example198">
<p>One way to look at a relation is to regard it as a directed graph: that is, a collection of things (&quot;vertices&quot;) with arrows drawn between them (&quot;edges&quot;). We write our items A, B, C, ... on a piece of paper: then, if A relates to B, we draw an arrow pointing from A to B, and so on. If we made this drawing for the adjacency relation, we would more or less have reconstructed the map (or at least a simplified one which does not care about precise directions, like the famous diagram of the London Underground). But the drawing can be made for any relation. If we define:</p>
<!-- START CODE "c11241" -->
<a id="c11241"></a><blockquote class="code"><p class="quoted">
Suspecting relates various people to one person.
</p></blockquote>
<!-- END CODE -->
<p>then, in the corresponding graph, each &quot;vertex&quot; will have at most one arrow leading away from it - though there could be many (or none) leading towards. Conversely, a one-to-various relation produces a graph where each vertex has at most one arrow coming in. A one-to-one relation means that the picture consists of some vertices on their own, with no arrows, a few perhaps with looped arrows leading from and to themselves, and then a collection of pairs joined by arrows. On the other hand, a various-to-various relation is just a free-for-all, with no restrictions on the arrows. The relations:</p>
<!-- START CODE "c11242" -->
<a id="c11242"></a><blockquote class="code"><p class="quoted">
Meeting relates people to each other.
<br />Marriage relates one person to another.
</p></blockquote>
<!-- END CODE -->
<p>always have the property of working both ways round, and these are easiest to visualise by forgetting the direction of the arrows, so that they just become lines joining the vertices.</p>
<p>Inform uses a different algorithm for finding routes (&quot;the next step via R from A to B&quot;) in each of these cases, and internally it stores relations in different formats in the different cases, because it makes a big difference to the efficiency of Inform to minimise the storage required for a relation and the time taken to explore it.</p>
<p>All the cases are benign except for &quot;various to various&quot; - the most useful - and for its closely related symmetrical version, &quot;relates... to each other&quot;. Inform cannot afford to assume that the relation will be &quot;sparse&quot; (that is: that no vertex will have more than a certain number of arrows, or that the total number of arrows will be small), because it has no idea how the arrows will come and go during play. It therefore uses 1 bit of storage for each pair of objects. This sounds harmless, but if there are 200 rooms, there are 40,000 pairs of rooms, which means a 5000-byte allocation of storage (plus a handful of bytes as overhead). Gratuitous various-to-various relations are therefore not a good idea.</p>
<p>There is a standard algorithm for calculating shortest paths through a directed graph, but Inform does not always use it, because there is not always memory to store the required matrix of partial results. Inform's slow method, likely to be used on the Z-machine, requires a storage overhead which is equal to the number of vertices, not the square of that number, but the worst-case running time can be bad: if there are N vertices, and the diameter of graph (the longest distance between vertices) is D, then the running time is proportional to D times N. The worst case in finding routes from A to B is when almost every vertex can reach B, some across long trails, but A cannot. In the case of finding routes across the game's map, this must be multiplied further by the number of possible directions - usually 16.</p>
<p>This does not sound too awful, but if one is trying to find (say) &quot;the most distant room from A&quot;, that means a further loop and now the running time will be D times N squared. Extension writers will need to be careful of this kind of thing: it is easy to write highly cool prototypes which work terribly slowly on larger, more realistic maps.</p>
</div>
<!-- EXAMPLE END -->
<div class="egovalforxref overstruckimage">
<!-- EXAMPLE START -->
<a  href="Rex198.html#e198"><i>RB</i></a></div>
<div class="egpanel" id="example198">
<p>One way to look at a relation is to regard it as a directed graph: that is, a collection of things (&quot;vertices&quot;) with arrows drawn between them (&quot;edges&quot;). We write our items A, B, C, ... on a piece of paper: then, if A relates to B, we draw an arrow pointing from A to B, and so on. If we made this drawing for the adjacency relation, we would more or less have reconstructed the map (or at least a simplified one which does not care about precise directions, like the famous diagram of the London Underground). But the drawing can be made for any relation. If we define:</p>
<!-- START CODE "c11243" -->
<a id="c11243"></a><blockquote class="code"><p class="quoted">
Suspecting relates various people to one person.
</p></blockquote>
<!-- END CODE -->
<p>then, in the corresponding graph, each &quot;vertex&quot; will have at most one arrow leading away from it - though there could be many (or none) leading towards. Conversely, a one-to-various relation produces a graph where each vertex has at most one arrow coming in. A one-to-one relation means that the picture consists of some vertices on their own, with no arrows, a few perhaps with looped arrows leading from and to themselves, and then a collection of pairs joined by arrows. On the other hand, a various-to-various relation is just a free-for-all, with no restrictions on the arrows. The relations:</p>
<!-- START CODE "c11244" -->
<a id="c11244"></a><blockquote class="code"><p class="quoted">
Meeting relates people to each other.
<br />Marriage relates one person to another.
</p></blockquote>
<!-- END CODE -->
<p>always have the property of working both ways round, and these are easiest to visualise by forgetting the direction of the arrows, so that they just become lines joining the vertices.</p>
<p>Inform uses a different algorithm for finding routes (&quot;the next step via R from A to B&quot;) in each of these cases, and internally it stores relations in different formats in the different cases, because it makes a big difference to the efficiency of Inform to minimise the storage required for a relation and the time taken to explore it.</p>
<p>All the cases are benign except for &quot;various to various&quot; - the most useful - and for its closely related symmetrical version, &quot;relates... to each other&quot;. Inform cannot afford to assume that the relation will be &quot;sparse&quot; (that is: that no vertex will have more than a certain number of arrows, or that the total number of arrows will be small), because it has no idea how the arrows will come and go during play. It therefore uses 1 bit of storage for each pair of objects. This sounds harmless, but if there are 200 rooms, there are 40,000 pairs of rooms, which means a 5000-byte allocation of storage (plus a handful of bytes as overhead). Gratuitous various-to-various relations are therefore not a good idea.</p>
<p>There is a standard algorithm for calculating shortest paths through a directed graph, but Inform does not always use it, because there is not always memory to store the required matrix of partial results. Inform's slow method, likely to be used on the Z-machine, requires a storage overhead which is equal to the number of vertices, not the square of that number, but the worst-case running time can be bad: if there are N vertices, and the diameter of graph (the longest distance between vertices) is D, then the running time is proportional to D times N. The worst case in finding routes from A to B is when almost every vertex can reach B, some across long trails, but A cannot. In the case of finding routes across the game's map, this must be multiplied further by the number of possible directions - usually 16.</p>
<p>This does not sound too awful, but if one is trying to find (say) &quot;the most distant room from A&quot;, that means a further loop and now the running time will be D times N squared. Extension writers will need to be careful of this kind of thing: it is easy to write highly cool prototypes which work terribly slowly on larger, more realistic maps.</p>
</div>
<!-- EXAMPLE END -->
<!-- END IGNORE -->
</td></tr></table>
<hr />
</div>
<!-- START IGNORE -->
<!-- END IGNORE -->
</body>
</html>
